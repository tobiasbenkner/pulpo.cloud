Erstelle ein professionelles, vollständig dezentralisiertes i18n-System für Astro mit TypeScript.

### DAS KONZEPT: "Extreme Colocation & Automation"
Wir verzichten auf zentrale Konfigurationsdateien. Jede Seite (View) definiert ihre Routen, Übersetzungen und die Komponente selbst in einem eigenen Ordner (`src/views/[feature]/`). Eine zentrale Registry sammelt diese Informationen automatisch ein.

### ANFORDERUNGEN:
1.  **Struktur:** Dateien liegen in `src/views/[name]/` (z.B. `contact.astro`, `contact.i18n.ts`, `contact.route.ts`).
2.  **Automation:** `import.meta.glob` sammelt alle `.route.ts` Dateien ein.
3.  **SEO:** Absolute URLs (`Astro.site`), Canonical Tags, Hreflang.
4.  **Sitemap:** Eine dynamische `sitemap.xml`, die alle Sprachen und Routen enthält.
5.  **Typisierung:** Strenge TypeScript-Typen für Übersetzungsdateien (`TranslationSchema`).
6.  **Technik:** Nur ES Modules (`import`), kein `require`.

Bitte generiere den Code für die folgenden Dateien:

### 1. BASIS TYPEN (src/lib/types.ts)
Definiert die Sprachen und das Schema für Übersetzungen.

```typescript
export const languages = ['en', 'de', 'es'] as const;
export const defaultLang = 'en' as const;
export type Language = typeof languages[number];

// Type für die Route-Definition in den *.route.ts Dateien
export type RouteDefinition = {
  key: string;
  slugs: { [key in Language]: string };
};

// Generischer Type für Übersetzungsdateien (für Autocomplete & Safety)
export type TranslationSchema = Record<string, string | Record<string, string | Record<string, string>>>;
```

### 2. REGISTRY (src/lib/registry.ts)
Sammelt automatisch alle Routen ein.

```typescript
import { languages, defaultLang, type Language, type RouteDefinition } from '@/lib/types';

// GLOB IMPORT: Sammelt alle *.route.ts Dateien (eager = sofort verfügbar)
const routeFiles = import.meta.glob<Record<string, RouteDefinition>>('/src/views/**/*.route.ts', { eager: true });

export const routeSlugs: Record<string, Record<Language, string>> = {};

// Aufbau der Registry
Object.values(routeFiles).forEach((module) => {
  const definition = module.route || module.default;
  if (definition && definition.key && definition.slugs) {
    routeSlugs[definition.key] = definition.slugs;
  }
});

/**
 * Gibt den übersetzten Pfad zurück (Relativ)
 */
export function getTranslatedPath(routeKey: string, lang: Language): string {
  const slugs = routeSlugs[routeKey];
  
  // Sonderfall Homepage
  if (routeKey === 'home') {
     return lang === defaultLang ? '/' : `/${lang}`;
  }

  if (!slugs) {
    console.warn(`[Registry] Route key '${routeKey}' not found.`);
    return '/';
  }

  const slug = slugs[lang];
  return lang === defaultLang ? `/${slug}` : `/${lang}/${slug}`;
}
```

### 3. I18N CORE (src/lib/i18n.ts)
Proxy-Logik und Pfad-Helper.

```typescript
import { defaultLang, type Language, languages } from '@/lib/types';
import type { TranslationSchema } from '@/lib/types';

export function createTranslationProxy<T extends TranslationSchema>(
  translations: Record<Language, T>,
  lang: Language
): T {
  const handler: ProxyHandler<T> = {
    get(target, prop: string | symbol) {
      if (typeof prop === 'string') {
        const value = target[prop];
        // Rekursion für nested Objects
        if (value && typeof value === 'object' && !Array.isArray(value)) {
          return new Proxy(value, handler as any);
        }
        // Fallback
        return target[prop] ?? translations[defaultLang][prop];
      }
      return target[prop as keyof T];
    }
  };
  return new Proxy(translations[lang], handler);
}

export function getStaticLanguagePaths() {
  return languages.map(lang => ({
    params: { lang: lang === defaultLang ? undefined : lang }
  }));
}
```

### 4. SITEMAP (src/pages/sitemap.xml.ts)
Generiert die XML-Sitemap dynamisch basierend auf der Registry.

```typescript
import { languages } from '@/lib/types';
import { routeSlugs, getTranslatedPath } from '@/lib/registry';
import type { APIRoute } from 'astro';

export const GET: APIRoute = ({ site }) => {
  const baseUrl = site?.toString().replace(/\/$/, '') || 'http://localhost:4321';
  
  // Erstelle Einträge für Home + alle registrierten Routen
  const allRouteKeys = ['home', ...Object.keys(routeSlugs)];

  const urls = allRouteKeys.flatMap(key => {
    return languages.map(lang => {
      const path = getTranslatedPath(key, lang);
      return `
        <url>
          <loc>${baseUrl}${path}</loc>
          <lastmod>${new Date().toISOString().split('T')[0]}</lastmod>
        </url>
      `.trim();
    });
  });

  return new Response(
    `<?xml version="1.0" encoding="UTF-8"?>
    <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
      ${urls.join('')}
    </urlset>`,
    {
      headers: {
        'Content-Type': 'application/xml'
      }
    }
  );
};
```

### 5. SEO HEAD KOMPONENTE (src/components/SeoHead.astro)
```astro
---
import { languages, defaultLang } from '@/lib/types';
import { getTranslatedPath } from '@/lib/registry';
import type { Language } from '@/lib/types';

interface Props {
  title: string;
  description: string;
  routeKey: string;
  currentLang: Language;
}

const { title, description, routeKey, currentLang } = Astro.props;
const baseUrl = Astro.site?.toString().replace(/\/$/, '') || 'http://localhost:4321';

const canonicalURL = `${baseUrl}${getTranslatedPath(routeKey, currentLang)}`;

const alternateLinks = languages.map(lang => ({
  lang,
  href: `${baseUrl}${getTranslatedPath(routeKey, lang)}`
}));
---

<title>{title}</title>
<meta name="description" content={description} />
<link rel="canonical" href={canonicalURL} />

{alternateLinks.map(link => (
  <link rel="alternate" hreflang={link.lang} href={link.href} />
))}
<link rel="alternate" hreflang="x-default" href={`${baseUrl}${getTranslatedPath(routeKey, defaultLang)}`} />
```

### 6. LANGUAGE SWITCHER (src/components/LanguageSwitcher.astro)
```astro
---
import { languages } from '@/lib/types';
import { getTranslatedPath } from '@/lib/registry';
import type { Language } from '@/lib/types';

interface Props {
  lang: Language;
  routeKey: string;
}
const { lang, routeKey } = Astro.props;
---
<nav>
  {languages.map(l => (
    <a href={getTranslatedPath(routeKey, l)} hreflang={l} class={l === lang ? 'active' : ''}>
      {l.toUpperCase()}
    </a>
  ))}
</nav>
```

### 7. LAYOUT (src/layouts/Layout.astro)
```astro
---
import SeoHead from '@/components/SeoHead.astro';
import LanguageSwitcher from '@/components/LanguageSwitcher.astro';
import type { Language } from '@/lib/types';

interface Props {
  title: string;
  description: string;
  lang: Language;
  routeKey: string;
}
const { title, description, lang, routeKey } = Astro.props;
---
<!DOCTYPE html>
<html lang={lang}>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <SeoHead title={title} description={description} routeKey={routeKey} currentLang={lang} />
  </head>
  <body>
    <header><LanguageSwitcher lang={lang} routeKey={routeKey} /></header>
    <main><slot /></main>
  </body>
</html>
```

### 8. VIEW BEISPIEL (Colocation)
Ordner: `src/views/contact/`

**a) src/views/contact/contact.route.ts**
```typescript
import type { RouteDefinition } from '@/lib/types';

export const route: RouteDefinition = {
  key: 'contact',
  slugs: { en: 'contact', de: 'kontakt', es: 'contacto' }
};
```

**b) src/views/contact/contact.i18n.ts**
```typescript
import type { TranslationSchema } from '@/lib/types';

export const translations = {
  en: { meta: { title: 'Contact', desc: 'Msg us' }, form: { send: 'Send' } },
  de: { meta: { title: 'Kontakt', desc: 'Schreib uns' }, form: { send: 'Senden' } },
  es: { meta: { title: 'Contacto', desc: 'Escríbenos' }, form: { send: 'Enviar' } }
} satisfies Record<string, TranslationSchema>;
```

**c) src/views/contact/ContactPage.astro**
```astro
---
import type { Language } from '@/lib/types';
// Type-Safe Props
interface Props { t: any; lang: Language; }
const { t } = Astro.props;
---
<h1>{t.meta.title}</h1>
<button>{t.form.send}</button>
```

### 9. PAGE CATCH-ALL (src/pages/[...lang]/[slug].astro)
Importiert Views und mappt sie, nutzt aber die Registry für Pfade.

```astro
---
import { defaultLang, languages, type Language } from '@/lib/types';
import { createTranslationProxy } from '@/lib/i18n';
import { routeSlugs } from '@/lib/registry';
import Layout from '@/layouts/Layout.astro';

// 1. IMPORTS DER VIEWS
import ContactPage from '@/views/contact/ContactPage.astro';
import { translations as contactTrans } from '@/views/contact/contact.i18n';

import AboutPage from '@/views/about/AboutPage.astro';
import { translations as aboutTrans } from '@/views/about/about.i18n';

// 2. MAPPING CONFIG
const pageConfig: Record<string, any> = {
  'contact': { Component: ContactPage, translations: contactTrans },
  'about': { Component: AboutPage, translations: aboutTrans },
};

export function getStaticPaths() {
  // Generiert Pfade basierend auf Registry
  return Object.entries(routeSlugs)
    .filter(([key]) => key !== 'home')
    .flatMap(([routeKey, slugs]) => {
      return languages.map(lang => ({
        params: { 
          lang: lang === defaultLang ? undefined : lang,
          slug: slugs[lang]
        },
        props: { lang, routeKey }
      }));
    });
}

const { lang, routeKey } = Astro.props;
const config = pageConfig[routeKey];
if (!config) return Astro.redirect('/404');

const { Component, translations } = config;
const t = createTranslationProxy(translations, lang as Language);
---
<Layout title={t.meta.title} description={t.meta.desc} lang={lang} routeKey={routeKey}>
  <Component t={t} lang={lang} />
</Layout>
```